== Templates
_Formatting pipeline output for humans!_

In contrast to traditional command-line programs, the output of a Cog command is not plain text, but a JSON object. This common structure makes it easy to chain commands together into pipelines because downstream commands can easily reach into the JSON output to extract the data they need, without having to jump through the various text manipulation steps that are so frequently part of traditional command-line pipelines. When it's time to present the final output of a pipeline, however, we often want something a bit more user-friendly than a dump of JSON data in our chat window.

To address this, Cog commands have the ability to specify a template that will be used to process the final pipeline output into a more readable format. This allows commands to return rich JSON objects for maximum flexibility in pipelines, but also condense these objects down to the salient information that humans need in chat ("Bundle 'foo', version '1.0.0' was enabled", for example).

=== Basic Greenbar Syntax

The template language used by Cog is https://github.com/operable/greenbar[Greenbar], a language created by Operable for the needs of Cog. It is probably best described as a Markdown variant, with support for ERB-like tags.

Many familiar Markdown features are available, including boldface, italics, ordered and unordered lists, and monospace formatting; even tables. Iteration and conditional logic (among other features) are achieved through the use of "tags". Data from result objects can be accessed through variable references. This example will illustrate many Greenbar features:

.Example Greenbar Template
[source, Markdown]
----
~if cond=length($results) == 1~
The _only_ member of the group is **~$results[0].username~**.
~end~
~if cond=length($results) > 1~
The group has the following members:
~each var=$results as=user~
1. ~$user.username~
~end~
~end~
----

Note that all Greenbar instructions are enclosed in `~` characters. Some, like `~if~` and `~each~` have bodies, with corresponding `~end~` terminators; bodies may contain plain text, or other Greenbar instructions. Variable dereferencing is achieved with the use of the `$` operator within Greenbar instructions. Complex objects can be navigated using familiar dot notation, and individual array members can be addressed by a zero-based index. Markdown does not require special Greenbar instructions, but is used directly (observe the italics on "only", the bolding of the single user's name, and the generation of an ordered list in the `~each~` iterator). Note also the presence of the top-level "results" key, containing all the output of the Cog pipeline.

.TL;DR - How Do I Write Templates?!
NOTE: While this document gives an overview of Greenbar, the best source of documentation for the Greenbar system can be found in https://github.com/operable/greenbar[Greenbar's code].
 +
 Template authors will want to pay particular attention to the documentation for https://github.com/operable/greenbar/blob/master/lib/greenbar/tags[individual tags] in the Greenbar repository.
 +
 Numerous example Greenbar templates can also be found in https://github.com/operable/cog/tree/master/priv/templates[Cog itself].

=== Overall Template Processing Logic

In order to write effective templates, it helps to understand a bit about how Cog processes the output of pipelines, how templates are chosen, and how pipeline data is presented to the template.

==== All pipelines return a "results" list

For all successful pipeline runs, Cog will return a single JSON object to the template. This object will have a "results" key, which is always a list of objects returned from individual command invocations (it's a list whether there is only a single result object or many).

==== Commands can specify a template when they return to Cog

When each command runs, it has the option of specifying a template to use when formatting the output by returning a `COG_TEMPLATE` value in the output. The name of the template is resolved relative to the bundle the command is a member of. If no template is specified, then Cog will fall back to one of two "common" templates. If the command returns bare text (instead of JSON, as is customary), then a special "text" template is used. On the other hand, if JSON is returned, then the "raw" template is used, which will pretty-print the results.

==== Last output "wins"

The return value of every Cog command invocation can specify a template to use, but pipelines can trigger multiple invocations in the course of processing. That can theoretically result in multiple templates being specified.

Templates are only truly needed at the end of a pipeline, however. If a command in the middle of a pipeline declares that its output should be formatted with the "foo" template, we don't care, because we know that output is going to be modified further by the downstream commands. As soon as Cog wraps up one pipeline stage and moves on to the next, all template information collected to that point is discarded.

With respect to templating, it is the final stage that we care about. With Cog's current implementation, each invocation can theoretically specify a different template; in reality, though, only the template specified by the final invocation is used to template all the data.

==== Meta-templates, not Templates

Cog's templates are not actually templates, but rather "meta-templates". They do not generate text, but rather _directives_, instructions on how to render text. This allows individual chat providers to determine exactly how to format a given template. For example, the Slack provider can interpret a `bold` directive as `*bold text*`, while a HipChat provider can interpret the same directive as `<b>bold text</b>`.

.Slack's Directive Processor
NOTE: You can see how Greenbar directives are processed for Slack in the code https://github.com/operable/cog/blob/72308c31f49e8d8369f48ec1dd932403117e232c/lib/cog/chat/slack/template_processor.ex[here].

By using this architecture, command authors only need to write a single template, which each chat provider can interpret in the best way for its host platform, instead of having to supply a template for each chat provider individually.

.A Familiar Architecture
NOTE: The rendering of Greenbar templates to general directives, which are then processed by chat adapter-specific processors, is analogous to the interpretation of Java bytecode on platform-specific VMs, or the rendering of OpenGL directives by different graphics processors.

=== Advanced Greenbar Usage

Greenbar includs a variety of tags to help you better organze your output and
also fully utilize the formatting options available from your chat provider.
But, so far, we've only seen a few simple tags like `~if~` and `~each~`. Let's
look at the other tags included and see how we can build our own custom tag.

==== Greenbar Tag Reference

===== if

Provides a small set of operators to express conditional logic. Conditionally
evaluates its body based on the value of the `cond` attribute.

====== Example

```
~if cond=$doit bound?~
Hello there!
~end~
```

Given the variable `$doit` is bound, the above template would produce:

```
Hello there!
```

Given that the variable `$doit` is not bound, the above template would produce
an empty string.

====== Operators

|=======
|Symbol |Name |Variable value types
|:--- |:--- |:---
|> |greater than |int, float
|>= |greater than equal |int, float
|< |less than |int, float
|<= |less than equal |int, float
|== |equal |int, float, string
|!= |not equal |int, float, string
|bound?| is bound |any
|empty?| is empty |list, map
|=======

===== Each

Iterates over a list binding each item to a variable scoped to the tag's body.
Uses the value of the `as` attribute as the name of the variable during each
iteration. If not provided it defaults to `item`.

====== Examples

Using the default body variable `item`:

```
~each var=$users~
First Name: ~$item.first_name~
Last Name: ~$item.last_name~
~end~
```

Customizing the body variable:

```
~each var=$users as=user~
First Name: ~$user.first_name~
Last Name: ~$user.last_name~
~end~
```

Given the variable `$users` is bound to `[%{"first_name" => "John", "last_name"
=> "Doe"}]` then both of the above templates would produce:

```
First Name: John
Last Name: Doe
```

==== Join

Iterates over a list, joining the rendered items with the value of the `with`
attribute, which defaults to `", "`. Similar to the `each` tag, you may also
provide an `as` attribute which sets the name of the variable scoped to the
body of the tag.

===== Examples

Create a comma-delimited list

```
~join var=$names~~$item~~end~
```

Given that the variable `$names` is bound to `["Mark", "Kevin", "Shelton"]`
then the above template would produce:

```
Mark, Kevin, Shelton
```

Specify a custom joiner

```
~join var=$names with="-"~~$item~~end~
```

Custom binding

```
~join var=$names as=name~~$name~~end~
```

Bodies can contain arbitrary instructions

```
~join var=$users~~$item.profile.username~~end~
```

==== Count

Returns the size of the referenced variable. When referencing lists the size is
the length of the list. For maps, size is the number of the map's unique keys.
Any other value type will display "N/A".

===== Examples

```
There are ~count var=$users~ users.
```

Given that the variable `$users` is bound to `[{ "name": "Mark" }, { "name":
"Kevin" }]` then the above template would produce:

```
There are 2 users.
```

Given that the variable `$users` is bound to `{ "imbriaco": 1, "kevsmith": 2,
"shelton": 3 }` then the above template would produce:

```
There are 3 users.
```

==== Break

Inserts a hard newline into the rendered template. This can be useful to work
around situtions where Markdown consolidates newlines.

===== Examples

Normally Markdown will combine two code blocks into one if they are separated
by a single newline.

```
`This is a line of code`
`This is another line of code`
```

will render as `This a line of codeThis is another line of code`

```
`This is a line of code`
~br~
`This is another line of code`
```

will render as

```
This is a line of code
This is another line of code
```

==== Attachment

Wraps body in an attachment directive. The initial design is heavily influenced
by Slack's attachment API.

===== Attributes

|======
|Name |Description
|title |Attachment title
|title_url |Optional title link URL
|color |Color to be used when rendering attachment (interpretation may vary by provider)
|image_url |Link to image asset (if any)
|author |Author name
|pretext |Preamble text displayed before attachment body
|footer |Brief text that appears as the attachment's footer
|======

Any other attributes will be interpreted as custom fields and included in the
attachments' `fields` field. Custom fields have the following structure:

```
{
  "title": <attribute_name>,
  "value": <attribute_value>,
  "short": false
}
```

===== Examples

The template

```
~attachment title="VM Use By Region" runtime=$timestamp~
|Region|Count|
|---|---|
~each var=$regions as=region~
|~$region.name~|~$region.vm_count~|
~end~
~end~
```

when executed with the data

```
%{"timestamp" => "Mon Sep 12 13:06:57 EDT 2016",
 "regions" => [%{"name" => "us-east-1", "vm_count" => 113},
               %{"name" => "us-west-1", "vm_count" => 105}]}
```

generates the rendering directives


```
[%{name: :attachment,
   title: "VM Use By Region",
   fields: [%{short: false,
              title: "runtime",
              value: "Mon Sep 12 13:06:57 EDT 2016"}],
              children: [%{name: :table, children: [%{name: :table_header,
                                  children: [%{name: :table_cell,
                                           children: [%{name: :text, text: "Region"}]},
                                         %{name: :table_cell,
                                           children: [%{name: :text, text: "Count"}]}]},
                            %{name: :table_row,
                              children: [%{name: :table_cell,
                                           children: [%{name: :text, text: "us-east-1"}]},
                                         %{name: :table_cell,
                                           children: [%{name: :text, text: "113"}]}]},
                            %{name: :table_row,
                              children: [%{name: :table_cell,
                                           children: [%{name: :text, text: "us-west-1"}]},
                                         %{name: :table_cell,
                                           children: [%{name: :text, text: "105"}]}]}]}]}]
```

==== Json

Generates a code block containing the pretty-printed JSON encoding of a
variable.

===== Examples

With `my_json` equal to

```
{
  "foo": "bar",
  "stuff": {
    "hello": "world"
  }
}
```

the template

```
~json var=$my_json~
```

would render the text

```
{
  "foo": "bar",
  "stuff": {
    "hello": "world"
  }
}
```

=== Writing a custom tag

All of the tags we've covered were implemented in Elixir using the
`Greenbar.Tag` module, which you can also use to write your own custom tags.
Before we dive into writing our own, let's take a look at a super-simple
example, the `~br~` tag:

[source, Elixir]
----
defmodule Greenbar.Tags.Break do
  use Greenbar.Tag, name: "br"

  def render(_id, _attrs, scope) do
    {:halt, %{name: :newline}, scope}
  end
end
----

First, we `use Greenbar.Tag` to set the name of the tag that we'll use in the
template. Then, we implement `render` which returns a newline. The `:halt`
symbol in the tuple returned means that the tag has finished rendering and we
can continue processing the rest of the template. There are a few more ways we
can output values which are more useful in tags that accept a body as we'll see
in the next example.

Now to implement our own tag. Let's build a tag that converts the body to
uppercase. For a template like this:

```
~upcase~
hello world
~end~
```

we'll expect the final result to be:

```
HELLO WORLD
```

To start we can open up a new file named `upcase.ex` and start out with an
empty module and `use Greenbar.Tag` to set the name.

[source, Elixir]
----
defmodule Upcase do
  use Greenbar.Tag, name: "upcase"
end
----

Next, we need to implement the `render` function using a new tuple, `{:once,
scope, child_scope}`. This creates a new scope for our tag body.

[source, Elixir]
----
def render(_id, _attrs, scope) do
  child_scope = new_scope(scope)
  {:once, scope, child_scope}
end
----

I know what you're thinking, "Where's the `String.upcase` call?" Well, the
render call is useful for changing scope and returning pre-defined results, but
if you want to modify the body of a tag, you'll need to implement a `post_body`
function. `post_body` gives you access to the attributes of the tag, the
outside scope, the scope of the body and a buffer containing all the parsed
items from the template. All we need to do is to iterate over the items in the
buffer and upcase anything that contains text.

[source, Elixir]
----
def post_body(_id, _attrs, scope, _body_scope, %Buffer{items: items}) do
  {:ok, scope, %Buffer{items: Enum.map(items, &upcase_directive/1)}}
end

def upcase_directive(%{name: :text, text: text} = directive),
  do: %{directive | text: String.upcase(text)}
def upcase_directive(directive),
  do: directive
----

NOTE: You'll also have to include `alias Greenbar.Runtime.Buffer` at the top of
the module.

And that should do it. Your final custom tag module will look like the
following:

[source, Elixir]
----
defmodule Cog.Tags.Upcase do
  use Greenbar.Tag, name: "upcase", body: true
  alias Greenbar.Runtime.Buffer

  def render(_id, _attrs, scope) do
    child_scope = new_scope(scope)
    {:once, scope, child_scope}
  end

  def post_body(_id, _attrs, scope, _body_scope, %Buffer{items: items}) do
    {:ok, scope, %Buffer{items: Enum.map(items, &upcase_directive/1)}}
  end

  def upcase_directive(%{name: :text, text: text} = directive),
    do: %{directive | text: String.upcase(text)}
  def upcase_directive(directive),
    do: directive
end
----

To use this with Cog, we're going to need to include this module in the Cog
codebase and set it as an available tag when creating the `Greenbar.Engine`.
Move the `upcase.ex` file we just created to `lib/cog/tags/upcase.ex` and
rename the module to `Cog.Tags.Upcase`. Now open up
`lib/cog/template/new/evaluator.ex` and scroll down to the bottom of the file
to find the `do_evaluate` function. We need to add the `upcase` tag to the
engine. Directly after the line where we create the engine, include this line
to add our tag:

[source, Elixir]
----
{:ok, engine} = Engine.add_tag(engine, Cog.Tags.Upcase)
----

The end result should look like:

[source, Elixir]
----
def do_evaluate(name, source, data) do
  {:ok, engine} = Engine.new
  {:ok, engine} = Engine.add_tag(engine, Cog.Tags.Upcase)
  engine
  |> Engine.compile!(name, source)
  |> Engine.eval!(name, data)
end
----

And that's it, just restart Cog and you can use your new `~upcase~` tag in any
template.

=== Customizing the standard error template

Cog uses a standard template to render errors that might occur when processing a pipeline. For example, when a user types the name of a command that does not exists, or if a command were to crash unexpectedly. The standard template contains a lot of information that is useful when developing bundles, but may a bit to much info for the average user. For this reason, it can be easily customized.

==== Configuring

Configuring Cog to use a custom error template is a two step process. First create a template called `error.greenbar` and place it in an empty directory accessible to Cog. Then set <<COG_CUSTOM_TEMPLATE_DIR>> to the path of said directory. After setting the env var you can update or remove the custom template file directly. No Cog restarts are required.

==== error.greenbar

Like all templates in Cog, the standard error template is written in greenbar. See <<Basic Greenbar Syntax>> for more info. Unlike templates defined for commands though, the standard error template does not receive a "results" list. Instead it receives a single object containing information about the error.

The error object contains the following keys:

id::
  The id of the pipeline.
started::
  The time stamp for the start of the pipeline.
initiator::
  The username of the one who initiated the pipeline.
pipeline_text::
  The complete text of the pipeline.
error_message::
  The error message returned by the pipeline.
planning_failure::
  When a pipeline fails during it's planning stage, ie during variable binding or when interpreting options, this will contain the portion of the pipeline that generated the error. Otherwise this will be `false`.
execution_failure::
  Similar to `$planning_failure`; when a pipeline fails during execution of the pipeline, this will contain the portion of the pipeline that caused the error. Otherwise this is set to `false`.

.The default error.greenbar as an example
[source, Markdown]
----
~attachment title="Command Error" color="#ff3333" Caller=$initiator Pipeline=$pipeline_text "Pipeline ID"=$id Started=$started~
~if cond=$planning_failure ~
The pipeline failed planning the invocation:
~br~
```
~$planning_failure~
```
~end~
~if cond=$execution_failure~
The pipeline failed executing the command:
~br~
```
~$execution_failure~
```
~end~
~br~
~br~
The specific error was:
~br~
```
~$error_message~
```
~end~
----
